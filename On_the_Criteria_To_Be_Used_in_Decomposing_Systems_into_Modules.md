# [译] 系统分解为模块的标准

---

> 原文：[On the Criteria To Be Used in Decomposing Systems into Modules][1]
作者：D.L. Parnas Carnegie-Mellon University

## 摘要
模块化这种机制有利于提高系统的灵活性与可理解性，并缩短系统的开发时长，本文将对此进行讨论。「模块化」的效果取决于将系统分解为模块时所遵循的标准。下文将提出系统设计中存在的问题，并会对常规和非常规的分解方法进行描述。并且，本文会展示非常规分解方式对于整体目标的显著优势，以及实现分解的过程中所使用的相关标准。此外，在「一个模块由一个或多个子程序组成」这一传统假设下，非常规分解方法于大多数情况下效率较低，而下文将阐述另一种实现方式。

关键词：软件、模块、模块性、软件工程、KWIC 索引、软件设计

## 介绍
1970 年 Gouthier 与 Pont 所著的有关系统编程设计的课本中首次提出了模块化编程的定义：
> 系统分工的明确性确保了系统的模块性。每个任务都形成了一个独立的、不同的模块。在实现阶段，每个模块及其输入和输出都已被明确地定义，这意味着在模块间的预期接口中不会存在不确定性。在检测阶段，模块的完整性会被单独测试；而在检测开始前，多任务完成情况的同步过程也很少会出现调度问题。最终，系统会在模块层面进行维护；系统的错误和缺陷将易于定位到具体的模块，从而缩小了具体错误的排查范围。

将系统分解为模块的过程中可以遵循的标准通常不会被提及。本文将会讨论这个问题，并通过一些例子，提出在系统分解至模块的过程中可以使用的标准。

## 简要状态报告
近年来模块化编程领域的主要发展在于编码技术与编译水平的发展。这些发展使得开发者无需对另一模块的实现过多了解，便可以对本模块进行开发。此外，单个模块的重组与替换也不会导致系统整体的重组。这种机制对大段代码的产出具有极大的意义，但在使用上述技术的情况下，对系统进行过度的模块处理也是经常发生的问题。

## 模块化编程的预期优势
模块化编程的预期优势在于：
1. 管理层面：由于不同的开发团队无需沟通便可对各自的模块进行开发，整体的开发时间会被缩短；
2. 产品灵活性：一个模块可以在不影响其他模块的情况下做出大规模的修改；
3. 易于理解：系统设计者可以在某一时间段只了解某一模块，因而系统设计也会更加容易进行。

## 什么是模块化
以下是一些关于模块化的描述。在本文中，「模块」是一种责任分配而非子程序。模块化包括在独立模块的实现工作前所需完成的一些设计决策。尽管每一种选择都包含了不同的决定，这里的目的在于对系统层面的决策进行描述，也就是那些会影响到多个模块的决策。

## 举例：KWIC 索引输出系统
本文将以 KWIC index （译注：上下文关键词索引） 为例展开说明。KWIC 索引系统接收多行有序的文本，每行由一些有序的单词组成，单词包含一些有序的字符。每一行都可以通过不断地将处于首位的单词插入末尾实现循环移位（ circularly shifted ）。最终，系统将输出按照字母顺序排序的循环移位的可能结果。

这是一个规模较小的系统。除非在一些极端的情况下（如大量的数据输入或缺少软件支持），有经验的程序员可以在一到两周时间内完成对这一系统的开发。因而，对其中的难点进行模块编程不重要的。由于彻底处理一个真正的大型系统是不切实际的，我们不如就把这个问题当做一个大型项目对待。接下来本文将给出一个现行的模块化方法，以及另一种已在本科项目中成功使用的方法。

## 模块化方法一
我们对其进行如下的模块划分：
### 模块一：输入
该模块从输入介质中按行读取数据，并将它们存储起来以供其他的模块使用。字符会在这里以四个为一组打包成单词，并会插入一个无用的字符作为单词间的分界。该模块会为每一行提供一个索引指向该行的起始位置。

### 模块二：循环移位
本模块会在模块一处理结束后被调用。这里会提供一个索引，用以指向循环移位结果的首字符，以及该循环移位所属初始行在模块一输出的数据行数组中的行号，输入格式为（原行号，起始索引）。（译注：如输入包括 A, B, C 三行，行 A 存在 A1, A2 两种循环移位形式，则 A1 在模块二中的输出格式为 ( A, A1 的地址 )）；

### 模块三：按字母顺序排序
此模块将模块一与模块二的结果作为输入，并按照字母表顺序以模块二的输出格式输出一个数组。

### 模块四：输出
本模块使用模块一和模块三的结果，并产生包含所有循环移位结果的格式化输出。在复杂的系统中，功能的实现可能会有所不同：如标记每一行的起始位置、加入更多的指针用以记录信息、循环移位可能不会从一行的首个单词开始等等。

### 模块五：主控
这一模块只是用于控制其他四个模块的顺序。也包括一些错误信息处理和空间资源分配等功能。

需要说明的是，以上的表述不应作为确定性的文档。在工作开始前需要有更多信息被提供。在定义文档中应该提供一些图片用于展示关键格式、指针规范及调用规范等。在实现之前必须指明这些模块之间的接口。

这就是「模块化编程拥护者」们所指的模块化。系统被分成了一些明确定义了接口的模块；每个模块都可以被轻松理解和编码实现。小范围的实验表明，这几乎就是大多数程序员在任务分配时所提出的模块分解。

## 模块化方法二
让我们来看看下面这些模块：
### 模块一：存储模块（Line Storage）
此模块包含一些可以被其他模块调用函数或子程序。`CHAR(r, w, c)` 将会返回第 r 行，第 w 个单词，第 c 个字符的整型表示。`SETCHAR(r, w, c, d)` 会将第 r 行，第 w 个单词，第 c 个字符赋值为 d，就像是 `CHAR(r, w, c) = d`。`WORDS(r)` 会返回 r 行的单词数量。在调用这些函数的方式上会有一些限制；当违背这些限制时，程序将会跳转到错误处理子程序中。此外还有一些可以被使用的子程序，如行内的单词数量、当前存储的行数以及单词中的字符数。函数 `DELINE` 及 `DELWORD` 用于删除已存储行的部分内容。在引用文献中给出了类似模块的详细说明，这里不再赘述。

### 模块二：输入
这一模块从输入媒介中读入原始的文本行信息，并调用模块一进行内部存储。

### 模块三：循环移位
此模块的主要功能与模块一类似。这一模块创建了一个包含所有循环移位结果（而不是原始文本行）的容器。因而，我们可以通过调用 `CSCHAR(l, w, c)` 获取到第 l 行，第 w 个单词，第 c 个字符的值。该模块的输出遵循以下两点：（1）如果 i < j，表明第 i 种移位先于第 j 种移位；（2）对任意原始文本行的移位结果中，第一种移位情况为该原始文本行本身，第二种为在第一种情况下，将一个单词旋转（译注：把行首的单词移至行尾）所得的结果，以此类推。函数 `CSSETUP` 需要在其他函数被调用之前调用。关于这一模块的更为精确的描述可以查阅引用中的文献。

### 模块四：按字母顺序排序
此模块主要提供两个函数。其一，`ALPH`，这一函数需要在其他函数被调用前调用；其二，`ITH`，此函数会作为索引使用。`ITH(i)` 会给出按字母顺序排序后序号为 i 的循环引用的索引。有关这些函数的正式定义可以参见参考文献。

### 模块五：输出
这一模块会打印输出我们需要的文本行集合或循环移位集合。

### 模块六：主控
此模块的功能类似于与上一种模块分类方法的同名模块。

## 两种模块化方式的比较
总的来说，两种方案都可以实现功能。第一种方式很常规；第二种则已经在一个既有项目中成功使用了。二者都会将编程任务缩小为一些相对独立的、小的、可管理的程序编程中。

首先，我们可以注意到，两种分解方法都会共享所有数据及访问方式。我们的讨论是关于对可能相同的对象进行切分的两种不同方式。可想而知，采用这两种分解方法分解后的系统在重组后是相同的。二者的不同之处在于其分解后的任务分配及模块间的接口。两种方式所使用的算法也可能是一样的。但即使在运行中二者表现相同，它们也可能是完全不同的。这是由于系统在运行时的表现仅限于系统的运行时期；而其他的表现则在于其他方面，如应对改变、文档化、理解性等。采用这两种方式设计的系统在这些方面上是不尽相同的。

在应对变化的能力方面，随着环境的不同，一些设计决策将会存在改变的可能。以下罗列部分情况。
1. 输入格式。
2. 文本行的保存方式。在大型作业情况下，将所有的文本行一次性存储在系统内部是不切实际的。
3. 将字符打包成单词的方式。在一些情况下，我们可能面对的是小规模的数据，此时我们会希望将字符单独成词（而不是四个字符打包成一个单词）；单字符成词的方式会节省一些时间。在其他情况下，我们也许仍会打包，但采用的方式又可能不同。
4. 循环移位的存取形式。在之前的模块化方式中，我们为循环移位的结果放置了索引，而不是真实存储这些结果。同样的，在索引较小而内部空间较大的情况下，将这些结果写出可能会是一个更好的选择。或者，我们不选择在 `CSSETUP` 阶段进行准备，一切计算都会在诸如 `CSCHAR` 等其他函数调用阶段完成。
5. 排序问题。即采用对列表一次排序的方式，而不是在需要时对全部子项进行搜索，或像 Hoare's FIND 一样进行局部排序。在一些情况下，将用于排序的计算分散到产生索引的时间上是非常有利的。

通过以上这些变化可能，我们可以发现这两种模块化方式之间的差异。第一种变化在二者的第一模块中都受到了限制。第一种模块化方案在应对第二种变化时将导致全部模块的变动！第三种变化的影响也是这样。在第一种分解方式中，文本行在内部的存储会被所有程序所使用。而在第二种分解方式里，这种情况则完全不同了。有关文本行的存储方式信息被（第二种分解方式的）模块一完全隐藏了。任何有关存储策略的修改都会被局限于第一个模块之中！

在这一系统的其他版本中，分解结果中会存在一个额外的模块。存储模块中会使用一个符号表模块（参见引用文献）。这种改动情况同样不会为其他模块所见。

第四种变化会被限制于模块化方案二中的循环移位模块中。但在第一种模块化方案中，排序模块、输出程序都会感受到这种变化。

由于（第一种模块化方案的）输出模块在开始运作前需要已经处理好的索引，第一种模块化方案对于第五种变化的应对同样非常棘手。而由于第二种模块化方案中的排序模块已经经过了精心的设计，调用者不会察觉到排序过程的完成。因而其他模块也无需改动。

开发独立性方面，第一种模块化方案中模块间接口的设计会是复杂的格式设计和表组织，设计者将难以轻易地给出设计决策。就各个模块的效率而言，接口设计相关的表结构和组织形式至关重要，需要精心的设计。这些格式的开发也会成为模块开发的主要组成部分，并且需要许多开发团队的共同努力。在第二个模块化方案中，接口则更为抽象；它们主要由函数名及参数的数量与类型组成。这些设计相对易于决策，且模块间的独立开发也更容易开展。

理解性方面，为了了解第一种模块化方案中的输出模块，我们有必要了解一些排序、循环移位以及输出模块的信息。而系统设计表中的一些方面只会在用于输出时才会有意义。由于一些在其他模块中使用的算法，表的结构会受到限制。系统只有在作为整体时才能易于理解。就主观评价而言，这些情况在第二种模块化方式中是不同的。

## 标准

接下来我们讨论每种分解方式中所使用的标准。在第一种分解方案中，每一个主要步骤都作为了一个模块。我们可能会从第一种分解方案中得到一份流程图。这是分解或模块化的一种常见方法。这其实是培训所导致的，程序员们被教导先绘制粗略的流程图，然后依此进行细节方面的实现。这种流程图对于那种具有 5000 到 10000 个指令的系统来说是很有作用的抽象，但当系统的规模超越这一范围时，它就显得不那么足够了；往往需要添加一些额外的东西。

第二种分解方案将「信息隐藏」作为一种标准。模块不在对应于过程中的步骤。例如，系统中几乎所有的行为都会运用到文本行存储模块。依据使用的方法，排序模块可能会、也可能不会对应于处理过程中的某个阶段。同样，在某些情况下，循环移位可能不会产生一些结果，而只是根据需要对字符进行计算。第二种分解方案中各个模块的特征在于设计决策阶段所赋予的功能领域，而实现这些功能所需具备的「知识」对于其他模块是隐藏的。它们的接口或定义被设计为尽可能少的暴露其中的工作机理。

## 循环移位模块的改进

为了说明这一标准的影响，让我们更进一步观察第二种模块方案式中循环移位模块的设计。出于预见性，我们断言这种模块定义表现出了过多的信息。虽然已经谨慎地隐藏了存储的方法及循环移位列表的运算，我们仍为该列表指定了顺序。如果我们仅做出如下指定，这一程序将更有效率：（1）循环移位所表示的行将全部存在于结果表中；（2）表中的内容不会重复；（3）存在额外的函数用于识别给定移位的原始行。通过规定移位的顺序，我们给出了更多的信息，也同样对系统中那些在修改定义时无需构建的类做了不必要的限制。例如，我们没有考虑到如下方面：循环移位排序后输出的时间、`ALPH` 函数为空，以及 `ITH` 函数只是简单的返回其参数的情况。在第二种模块化方案中，我们对于构建系统时所产生的错误必须被明确地归类为一种设计错误。

除了在各个模块中对剩余系统隐藏设计决策这一一般标准，我们会提出一些有建议价值的具体的分解的例子。
1. 数据结构及其内部链接、访问过程和修改过程都是单独模块的组成部分。它们不像通常那样被许多模块共享。这一观点可能只是 Balzer 和 Mealy 论文中猜想的一种延伸。这一设计思路来源于 BLISS（译注：参考文献的作者）。
2. 调用给定程序所需的指令序列同程序本身属于同一个模块。这一规则与本文所指的实验是不相关的，但在汇编构建的系统中，这一点显得非常重要。由于没有完美的通用调用序列，这种调用序列往往随着我们的不断探索而发生变化。通过为程序负责人分配生成调用序列的责任，我们使得这种改进更易实现，并使得在相同系统中拥有诸多不同的调用序列变得可行。
3. 在操作系统和相似程序队列中所使用的控制块格式必须隐藏在控制块模块内部。通常的做法是将这种格式作为不同模块间的接口。设计的发展迫使控制块格式的频繁改变，因而这种决策通常会带来极高的成本。
4. 为了更好的灵活性，字符编码、排序顺序以及类似的数据应该被隐藏在模块之中。
5. 某些项目的处理顺序应该被隐藏一个单独的模块中。因为从操作系统的设备添加，到某些资源不可用性的改变往往会使得处理顺序易于变化。

## 效率与实现
如果我们不仔细处理的话，第二种分解方案会比第一种效率更低。如果每一个功能都被实现为一种更为精细的调用序列的话，模块间就会因重复的切换而产生大量的调用。而这一问题在分解方案一中则不会出现，这是因为（分解方案一中的）模块间的控制切换没有那么频繁。

为了减少过程调用的开销，而获得我们之前所提到的各种优点，我们必须以一种非寻常的方式来实现这些模块。在很多情况下，程序最好被编译器插入到代码中；而在其他情况下，插入也可以自行指定。为了成功地、有效地应用第二种分解方法，我们需要使用一些工具，通过这些工具可以把函数当作子程序进行编程，但在组合时可以以任意一种合适的方式进行。如果使用这种技术，模块间的分离可能不会在最终的代码中表现出来。因此，额外的程序修改特性将会非常有利。也就是说，程序的多种表现（之前提到的）必须与执行他们之间映射的程序一起在一台机器中共同维护。

## 同一语言中通用于编译器及解释器的分解方案
在早期的将这些分解规则应用于项目设计的尝试中，我们应用文献[6]中的符号表示，构建了一个 Markov 算法的解释器。尽管探究语言编译器和解释器之间的关系并不是我们的目的，（在这一过程中）我们仍能发现（我们之前所提出的）分解方式对于纯编译器和一些语言解释器（的构建上）是有效的。尽管对于各种类型的编译器而言，它们在最终的运行表现中存在一些深层次、实质的不同，我们仍能发现早期分解过程中一些隐含的决策会对后续产生影响。

如果我们对编译器和解释器都按照经典标准进行责任分配（比如语法识别器、代码生成器、运行时程序编译等），那么以上的说法就是不对的。相反，像之前列举的例子一样，分解是对各种决策的隐藏。因而寄存器表示、搜索算法、规则解释等都是模块，并且这些问题在解释器和编译器中都有存在。不仅（我们所提出的）分解方案在所有情况下都有效，而且对于许多程序而言，只需稍加修改，它们便可以在任何解释器之中使用。

这个例子提供了额外的支持声明，进程发生时间的顺序不应被用于模块的分解中。它进一步提供了证据，证明细致的分解会使得相当多的工作从一个项目转移到另一个。

有关此例的更多讨论细节可以参见引用文献。

## 分层结构

在之前定义的应用第二种分解方案的系统中，我们可以发现一种程序分层，这种程序分层是由 Dijkstra （译注：引用文献的作者）所阐述的。符号表存在时，它的功能不必依赖其他模块即可发挥，因而它处于第一层级（level 1）。文本行存储在没有符号表的情况下处于第一层级，而在其他情况下处于第二层级。输入和循环移位需要文本行存储以实现各自的功能。输出和排序依赖循环移位，但由于循环移位和文本行容器在一定程度上互相兼容，我们很容易构建这些程序的参数化版本，用以对原始文本行或循环移位结果进行排序或输出。在最开始的使用中，它们并不需要使用循环移位功能；在第二阶段才需要。换句话说，我们的设计允许我们有一个可以运行于这两个层级的单独的程序。

在讨论系统结构时，很容易混淆系统分解与分层结构的好处。如果可以在模块和程序之间定义一个部分有序的关系，我们就拥有了一个分层结构。而这种关系通常是「调用」或「依赖」。由于很多情况下一个模块仅依赖于部分其他模块（如循环移位模块仅仅依赖于文本行容器的输出部分而不依赖 `SETWORD` 的功能），在程序中使用这种关系是很有好处的。我们也可以在不存在局部有序的情况下，获得我们之前所说的这些优点，比如所有的模块都处于同一层级。部分有序（的关系）产生了额外的两个优点。首先，由于可以调用下层服务，一部分系统会更为有利（简单）。第二，我们可以切断上层并依旧拥有可用且有用的产物。例如，符号表可以在其他应用中使用；文本行容器可以作为问答系统的基础。分层结构的存在确保我们可以「修剪」层级树的上层，并基于其他的层级重新构建系统。如果设计的系统中存在下级模块调用上级模块的情况，我们便失去了分层结构。这时我们会发现自己很难去除系统的某一部分，而在这类系统中，「分层」概念也不再有意义。

因为我们有可能会有一个具有分层结构（在接口中有着重要的设计决策）的第一版分解系统，我们必须得出结论，即分层结构和「纯粹的」分解方式是两种可取但独立的系统结构类型。

## 总结

我们试图通过这些例子阐述一个观点，即基于流程图的方式将系统分解为模块通常是不正确的。我们建议在（系统设计）开始前先列出设计决策的难点和容易更改的方面。每个模块都在设计中尽力对其他模块隐藏这些决策。在大多数情况下，设计决策的时间超过了执行时间，而模块则不会与流程中的步骤相对应。为了完成有效的项目实现，我们必须放弃模块就是一个或多个子程序的假设，并使得程序和子程序能够从不同的模块中被组合为代码集合。



---
## 译者注

> 译者：dailybird
译于：2017.3.19

### KWIC

有关 KWIC 可以参见 [KWIC.ppt][2] 中第 17 页。

### 参考

1. [Key Word in Context - Wikipedia][3]
2. [key-word-in-context index][4]


  [1]: https://www.cs.umd.edu/class/spring2003/cmsc838p/Design/criteria.pdf
  [2]: http://www.utdallas.edu/~maryellen.oltman/InterimIPPT.pdf
  [3]: https://en.wikipedia.org/wiki/Key_Word_in_Context
  [4]: https://zhidao.baidu.com/question/1575422138848859980.html